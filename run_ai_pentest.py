#!/usr/bin/env python3
"""
AI-Powered Penetration Testing System
Integration of Developmental (AI/ML) and Operational (UI/UX) Silos
"""

import sys
import os
import threading
import time
from datetime import datetime

# Add dev directory to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'dev'))

def main():
    """Main entry point for the AI Penetration Testing System"""
    
    print("üîê AI-Powered Penetration Testing System")
    print("=" * 60)
    print("Built with DevOps principles and advanced AI/ML capabilities")
    print("=" * 60)
    
    try:
        # Import AI components
        from dev.ai_core import AICore, AttackType, AttackResult
        from dev.unsupervised_learning import UnsupervisedLearning
        
        print("‚úÖ Developmental Silo: AI/ML Core loaded")
        
        # Initialize AI components
        ai_core = AICore()
        unsupervised_learning = UnsupervisedLearning()
        
        print("‚úÖ Unsupervised Learning: Pattern discovery engine loaded")
        
        # Check if UI is available
        try:
            import tkinter as tk
            from tkinter import ttk
            print("‚úÖ Operational Silo: UI/UX Interface available")
            ui_available = True
        except ImportError:
            print("‚ö†Ô∏è  UI not available, running in CLI mode")
            ui_available = False
        
        # Start the system
        if ui_available:
            print("üöÄ Starting GUI interface...")
            # Import and start GUI
            try:
                from ops.main_interface import ProgressiveLearningInterface
                app = ProgressiveLearningInterface()
                app.run()
            except ImportError:
                print("‚ö†Ô∏è  GUI not available, starting CLI mode")
                run_cli_mode(ai_core, unsupervised_learning)
        else:
            run_cli_mode(ai_core, unsupervised_learning)
            
    except ImportError as e:
        print(f"‚ùå Import error: {e}")
        print("üí° Please install dependencies:")
        print("   pip install numpy pandas scikit-learn tensorflow requests")
        return 1
    except Exception as e:
        print(f"‚ùå System error: {e}")
        return 1
    
    return 0


def run_cli_mode(ai_core, unsupervised_learning):
    """Run the system in CLI mode"""
    print("\nüéØ CLI Mode - AI Penetration Testing")
    print("=" * 40)
    
    while True:
        print("\nAvailable options:")
        print("1. üîç Quick Scan")
        print("2. ü§ñ Smart Attack")
        print("3. üß† Pattern Discovery")
        print("4. üìä Show Statistics")
        print("5. üö® Anomaly Detection")
        print("6. üìà Performance Analysis")
        print("7. üíæ Save Models")
        print("8. ‚ùå Exit")
        
        try:
            choice = input("\nSelect option (1-8): ").strip()
            
            if choice == "1":
                quick_scan(ai_core)
            elif choice == "2":
                smart_attack(ai_core)
            elif choice == "3":
                pattern_discovery(unsupervised_learning, ai_core)
            elif choice == "4":
                show_statistics(ai_core)
            elif choice == "5":
                anomaly_detection(unsupervised_learning, ai_core)
            elif choice == "6":
                performance_analysis(ai_core)
            elif choice == "7":
                save_models(ai_core)
            elif choice == "8":
                print("üëã Goodbye!")
                break
            else:
                print("‚ùå Invalid option. Please select 1-8.")
                
        except KeyboardInterrupt:
            print("\n\nüëã Goodbye!")
            break
        except Exception as e:
            print(f"‚ùå Error: {e}")


def quick_scan(ai_core):
    """Perform a quick scan"""
    print("\nüîç Quick Scan Mode")
    target = input("Enter target URL: ").strip()
    
    if not target:
        print("‚ùå Please enter a target URL")
        return
    
    print(f"üì° Scanning {target}...")
    
    # Simulate scan
    import requests
    try:
        response = requests.get(target, timeout=10)
        print(f"‚úÖ Target is reachable (Status: {response.status_code})")
        
        # Basic analysis
        print(f"üìä Response size: {len(response.text)} bytes")
        print(f"‚è±Ô∏è  Response time: {response.elapsed.total_seconds():.2f}s")
        
        # Check for common vulnerabilities
        if "error" in response.text.lower():
            print("‚ö†Ô∏è  Potential error disclosure detected")
        
        if "admin" in response.text.lower():
            print("‚ö†Ô∏è  Admin interface reference found")
            
    except requests.RequestException as e:
        print(f"‚ùå Error scanning target: {e}")


def smart_attack(ai_core):
    """Perform AI-powered smart attack"""
    print("\nü§ñ Smart Attack Mode")
    target = input("Enter target URL: ").strip()
    
    if not target:
        print("‚ùå Please enter a target URL")
        return
    
    print("Available attack types:")
    for i, attack_type in enumerate(AttackType, 1):
        print(f"{i}. {attack_type.value}")
    
    try:
        choice = int(input("Select attack type (1-5): ")) - 1
        attack_type = list(AttackType)[choice]
    except (ValueError, IndexError):
        print("‚ùå Invalid choice")
        return
    
    print(f"üéØ Starting {attack_type.value} attack on {target}...")
    
    # Perform attack
    max_attempts = 10
    previous_failures = []
    
    for attempt in range(max_attempts):
        # Generate adaptive payload
        payload = ai_core.generate_adaptive_payload(target, attack_type, previous_failures)
        
        # Predict success
        confidence = ai_core.predict_success(target, payload, attack_type)
        
        print(f"üéØ Attempt {attempt + 1}: Confidence = {confidence:.2f}")
        
        # Simulate attack
        success = confidence > 0.7
        
        # Create result
        result = AttackResult(
            attack_type=attack_type,
            target=target,
            payload=payload,
            success=success,
            response_code=200 if success else 403,
            response_time=0.5,
            confidence_score=confidence
        )
        
        # Learn from result
        ai_core.learn_from_result(result)
        
        if success:
            print(f"‚úÖ Attack successful! Payload: {payload}")
            break
        else:
            previous_failures.append(payload)
            print(f"‚ùå Attack failed. Learning...")
        
        time.sleep(0.5)
    
    print("üéØ Smart attack completed!")


def pattern_discovery(unsupervised_learning, ai_core):
    """Discover patterns using unsupervised learning"""
    print("\nüß† Pattern Discovery Mode")
    
    # Get attack history for analysis
    attack_data = []
    for result in ai_core.attack_history:
        attack_data.append({
            'target': result.target,
            'payload': result.payload,
            'success': result.success,
            'response_code': result.response_code,
            'response_time': result.response_time,
            'attack_type': result.attack_type.value
        })
    
    if not attack_data:
        print("‚ö†Ô∏è  No data available for pattern analysis")
        return
    
    print(f"üìä Analyzing {len(attack_data)} data points...")
    
    # Generate insights
    insights = unsupervised_learning.generate_insights(attack_data)
    
    print("üìà Pattern Analysis Results:")
    print("-" * 30)
    
    if 'key_findings' in insights:
        for finding in insights['key_findings']:
            print(f"üí° {finding}")
    
    if 'patterns' in insights and 'patterns' in insights['patterns']:
        patterns = insights['patterns']['patterns']
        if 'success_rate' in patterns:
            print(f"üìä Success Rate: {patterns['success_rate']:.2%}")
    
    print("‚úÖ Pattern discovery completed!")


def show_statistics(ai_core):
    """Show AI performance statistics"""
    print("\nüìä AI Performance Statistics")
    print("-" * 30)
    
    stats = ai_core.get_statistics()
    
    for key, value in stats.items():
        if isinstance(value, float):
            print(f"{key}: {value:.3f}")
        else:
            print(f"{key}: {value}")


def anomaly_detection(unsupervised_learning, ai_core):
    """Detect anomalies in attack data"""
    print("\nüö® Anomaly Detection Mode")
    
    # Get attack history
    attack_data = []
    for result in ai_core.attack_history:
        attack_data.append({
            'target': result.target,
            'payload': result.payload,
            'success': result.success,
            'response_code': result.response_code,
            'response_time': result.response_time,
            'attack_type': result.attack_type.value
        })
    
    if not attack_data:
        print("‚ö†Ô∏è  No data available for anomaly detection")
        return
    
    print(f"üîç Analyzing {len(attack_data)} data points for anomalies...")
    
    # Detect anomalies
    anomaly_results = unsupervised_learning.detect_anomalies(attack_data)
    
    print("üö® Anomaly Detection Results:")
    print("-" * 30)
    
    for method, result in anomaly_results.items():
        if 'anomaly_ratio' in result:
            print(f"{method}: {result['anomaly_ratio']:.2%} anomalies detected")
    
    print("‚úÖ Anomaly detection completed!")


def performance_analysis(ai_core):
    """Analyze system performance"""
    print("\nüìà Performance Analysis")
    print("-" * 30)
    
    stats = ai_core.get_statistics()
    
    if 'success_rate' in stats:
        success_rate = stats['success_rate']
        if success_rate > 0.8:
            print("üéØ Excellent performance!")
        elif success_rate > 0.6:
            print("‚úÖ Good performance")
        elif success_rate > 0.4:
            print("‚ö†Ô∏è  Moderate performance")
        else:
            print("‚ùå Poor performance - needs improvement")
    
    if 'patterns_learned' in stats:
        print(f"üß† Patterns learned: {stats['patterns_learned']}")
    
    if 'models_trained' in stats:
        print(f"ü§ñ Models trained: {stats['models_trained']}")


def save_models(ai_core):
    """Save trained models"""
    print("\nüíæ Saving Models")
    print("-" * 30)
    
    try:
        ai_core._save_models()
        print("‚úÖ Models saved successfully!")
    except Exception as e:
        print(f"‚ùå Error saving models: {e}")


if __name__ == "__main__":
    sys.exit(main()) 